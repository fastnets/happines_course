import logging
from datetime import time as dtime, timezone
import asyncio
from telegram.ext import Application

from entity.settings import get_settings
from entity.db import Database

from user.user_service import UserService
from learning.learning_service import LearningService
from scheduling.schedule_service import ScheduleService
from analytics.analytics_service import AnalyticsService
from questionnaires.questionnaire_service import QuestionnaireService
from admin.admin_service import AdminService
from core.ai_feedback_service import AiFeedbackService
from core.daily_pack_service import DailyPackService
from core.habit_service import HabitService
from scheduling.habit_schedule_service import HabitScheduleService

from user.user_handlers import register_user_handlers
from learning.learning_handlers import register_learning_handlers
from questionnaires.questionnaire_handlers import register_questionnaire_handlers
from admin.admin_handlers import register_admin_handlers
from scheduling.worker import tick
from debug.trace import register_trace

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(name)s: %(message)s")
log = logging.getLogger("happines_course")


def main():
    settings = get_settings()
    db = Database(settings)
    db.init_schema()

    services = {
        "user": UserService(db, settings),
        "learning": LearningService(db, settings),
        "schedule": ScheduleService(db, settings),
        "analytics": AnalyticsService(db, settings),
        "questionnaire": QuestionnaireService(db, settings),
        "admin": AdminService(db, settings),
        "ai": AiFeedbackService(),
        "habit": HabitService(db, settings),
        "habit_schedule": HabitScheduleService(db, settings),
    }

    # Daily packs (quote/tip/image/film/book) generated by UTC day.
    services["daily_pack"] = DailyPackService(db, settings, services["ai"], services["schedule"])

    app = Application.builder().token(settings.bot_token).build()

    # Seed admins from env (optional) into DB table `admins`.
    try:
        services["admin"].seed_admins_from_settings()
    except Exception:
        pass

    # Log every update to make handler order easier to understand.
    register_trace(app)

    # Admin handlers must be registered before user handlers (admin text wizard should win).
    register_admin_handlers(app, settings, services)
    register_user_handlers(app, settings, services)
    register_questionnaire_handlers(app, settings, services)
    register_learning_handlers(app, settings, services)

    # scheduler tick
    app.job_queue.run_repeating(lambda ctx: tick(ctx, services), interval=3, first=3)

    # Generate a new daily pack every day at 00:00 UTC (for everyone).
    async def _gen_daily_pack(context):
        svc = services.get("daily_pack")
        if not svc:
            return
        # run blocking generation in a thread
        await asyncio.to_thread(svc.generate_set_for_today, trigger="midnight", force=False)

    app.job_queue.run_daily(
        _gen_daily_pack,
        time=dtime(hour=0, minute=0, second=0, tzinfo=timezone.utc),
    )

    # ✅ Generate today's pack once on startup (so buttons work immediately)
    async def _startup_gen(context):
        svc = services.get("daily_pack")
        if not svc:
            return
        # create pack only if none yet for today
        await asyncio.to_thread(svc.generate_set_for_today, trigger="startup", force=False)

    app.job_queue.run_once(_startup_gen, when=1)

    async def on_error(update, context):
        log.exception("Unhandled error", exc_info=context.error)
        try:
            if update and update.effective_message:
                await update.effective_message.reply_text("⚠️ Упс, ошибка. Попробуй ещё раз.")
        except Exception:
            pass

    app.add_error_handler(on_error)

    log.info("Bot started")
    app.run_polling(allowed_updates=None)


if __name__ == "__main__":
    main()
